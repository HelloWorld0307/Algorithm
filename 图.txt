
图的遍历(由点及面) 条件1:刚好N-1条边 条件2:N个点连通 
问:如何用基本数据结构表示一个图?

178. 图是否是树
给出 n 个节点，标号分别从 0 到 n - 1 并且给出一个 无向 边的列表 (给出每条边的两个顶点), 写一个函数去判断这张｀无向｀图是否是一棵树

样例
样例 1:

输入: n = 5 edges = [[0, 1], [0, 2], [0, 3], [1, 4]]
输出: true.
思路：其实就是宽度优先搜索 + 图的存储

public class Solution {

    public boolean validTree(int n, int[][] edges) {
        // write your code here
        if (n == 0) {
            return false;
        }
        if (edges.length != n - 1) {
            return false;
        }
        Map<Integer, Set<Integer>> graph = initialGraph(n, edges);
        // 将二维数组转换为map类型的图后使用BFS处理
        Queue<Integer> queue = new LinkedList<>();
        Set<Integer> hash = new HashSet<>();
        
        // 因为节点是从0开始的所以0肯定是存在的
        queue.offer(0);
        // hash是用来记录已经访问过的节点
        hash.add(0);
        while(!queue.isEmpty()) {
            int size = queue.size();
            Integer cur = queue.poll();
            // 在map也就是graph中找多对应的key下个的set, 也就是当前cur节点的邻居
            for(Integer neighbor : graph.get(cur)) {
                if(hash.contains(neighbor)){ // 如果hash中已经保存neighbor节点直接跳过
                    continue;
                }
                queue.offer(neighbor);
                hash.add(neighbor);
            }
        }
        return (hash.size() == n);
    }
    
    // 图在数据库里面是以int[][]二维数组的形式存储，但是在内存中要将其转化为map类型，
    // 其中每个节点的所有邻居用一个Map<Integer, Set<Integer>>的形式表示
    public Map<Integer, Set<Integer>> initialGraph(int n, int[][] edges){
        Map<Integer, Set<Integer>> graph = new HashMap<>();
        // 一共有 n 个节点，标号分别从 0 到 n - 1 ，所以需要将这个点都存入到map中
        for(int i = 0; i < n; i++) {
            graph.put(i, new HashSet<Integer>());
        }
        // 接下来找到每一个节点的邻居点，使用set存储，set特性是不能存储重复数值
        for(int i = 0; i < edges.length; i++) {
            int u = edges[i][0];
            int v = edges[i][1];
            graph.get(u).add(v);     // 由于是无向图所以是0是1的邻居，那么反过来也是的
            graph.get(v).add(u);
        }
        return graph; // 最后求得的graph里面包含每一个节点，而且每一个节点的邻居节点都存储在set里面
    }
}


137. 克隆图
克隆一张无向图. 无向图的每个节点包含一个 label 和一个列表 neighbors. 保证每个节点的 label 互不相同.

你的程序需要返回一个经过深度拷贝的新图. 新图和原图具有同样的结构, 并且对新图的任何改动不会对原图造成任何影响.

样例

输入:
{1,2,4#2,1,4#4,1,2}
输出: 
{1,2,4#2,1,4#4,1,2}
解释:
1------2  
 \     |  
  \    |  
   \   |  
    \  |  
      4   
思路：1，通过给定的node节点找到所有的节点
    2，使用map的特性，将复制一份新节点存储在map中，其中key值为旧节点，value值为新节点
    3，找到一一对应的关系后是用循环遍历，首先遍历旧节点的中每一个节点的邻居，通过找到的这些邻居去map中找到新节点，然后存储在当前节点的邻居中

public class Solution {
    /*
     * @param node: A undirected graph node
     * @return: A undirected graph node
     */
     // 题目要求：将一个图完全的复制一份出来，对复制的新图修改不会影响旧图
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        // write your code here
        if(node == null) {
            return null;
        }
        // 1，根据给定的node找到所有的node节点，这些node节点包括节点label 和 节点的邻居节点
       ArrayList<UndirectedGraphNode> nodes = getAllNodes(node);
       
       // 2, 将新旧点一一对应关系存储在一个Map<UndirectedGraphNode, UndirectedGraphNode>类型中
       Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<>();
       for(UndirectedGraphNode oldNode : nodes) {
           map.put(oldNode, new UndirectedGraphNode(oldNode.label));
       }
       // 3，新旧点一一对应后，循环遍历旧图中所有节点其邻居节点
       for(UndirectedGraphNode n:nodes) {
           UndirectedGraphNode newNode = map.get(n);
           // 当前的neighbor是旧图里面的，我需要找到这个旧neighbor节点在新的中的节点
           for(UndirectedGraphNode neighbor : n.neighbors) {
               UndirectedGraphNode newNeightbor = map.get(neighbor);
               newNode.neighbors.add(newNeightbor);
           }
       }
       // 4，返回题目给定的node节点在新的mapping对应关系中的位置
       return map.get(node);
    }
    
    // 像这种给定一个点求得所有的点的有点求面类题目，第一反应就是使用宽度优先搜索
    private ArrayList<UndirectedGraphNode> getAllNodes(UndirectedGraphNode node){
        Queue<UndirectedGraphNode> queue = new LinkedList<>();
        Set<UndirectedGraphNode> set = new HashSet<>();
        queue.offer(node);
        set.add(node);
        while(!queue.isEmpty()){
            UndirectedGraphNode cur = queue.poll();
            for(UndirectedGraphNode neighbor : cur.neighbors){
                if(!set.contains(neighbor)){
                    // 如果set里面没有cur节点说明，还未遍历过
                    queue.offer(neighbor);
                    set.add(neighbor);
                }
            }
        }
        return new ArrayList<UndirectedGraphNode>(set);
    }
}



127. 拓扑排序
给定一个有向图，图节点的拓扑排序定义如下:

对于图中的每一条有向边 A -> B , 在拓扑排序中A一定在B之前.
拓扑排序中的第一个节点可以是图中的任何一个没有其他节点指向它的节点.
针对给定的有向图找到任意一种拓扑排序的顺序.

样例

The topological order can be:

[0, 1, 2, 3, 4, 5]
[0, 2, 3, 1, 5, 4]

// 思路：获取到图中每一个节点的入度，使用getInDegree方法获取的都是有入度的节点，查找哪个点在入度结果中不存在那么这个点就是出发点，
//     那么遍历这个点的所有邻居点，将其入度减一最后在判断其入度是否为0，如果为0则可以放大结果list中

public class Solution {

    public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
        
        // 1,找到每一个节点的入度，这里的result返回list都是入度不为零的节点
        ArrayList<DirectedGraphNode> result = new ArrayList<DirectedGraphNode>();
        Map<DirectedGraphNode, Integer> inDegree = getInDegree(graph);
        
        // 2,找到所有入度为0的节点，将其放在队列里--如果上一步返回的map中没有的节点就是入度为0的节点了
        Queue<DirectedGraphNode> queue = new LinkedList<>();
        for(DirectedGraphNode node : graph) {
            if(!inDegree.containsKey(node)){
                queue.offer(node);
                result.add(node);
            }
        }
        // 3,从队列里面拿出所有的节点，在队列里面的节点都是即将被写入结果map中的，这是需要找到所有的邻居
        //    节点，将这些邻居节点的入度减一，同时判断是否存在为如果为0的节点，如果是的入队列
        while(!queue.isEmpty()){
            DirectedGraphNode head = queue.poll();
            // 找到当前节点head的所有邻居，将其邻居的入度减一
            for(DirectedGraphNode neighbor : head.neighbors) {
                inDegree.put(neighbor, inDegree.get(neighbor) - 1);
                if(inDegree.get(neighbor) == 0){
                    queue.offer(neighbor);
                    result.add(neighbor);
                }
            }
        }
        return result;
    }
    
    // 有向图如果有A到B说明B是A的邻居，但是从B不到A说明B的neighbors里面没有A
    private Map<DirectedGraphNode, Integer> getInDegree(ArrayList<DirectedGraphNode> graph) {
        Map<DirectedGraphNode, Integer> result = new HashMap<>();
        for(DirectedGraphNode node : graph) {
            for(DirectedGraphNode neighbor : node.neighbors) {
                if(result.containsKey(neighbor)){
                    result.put(neighbor, result.get(neighbor) + 1);
                }else{
                    result.put(neighbor, 1);
                }
            }
        }
        return result;
    }
}

615. 课程表
现在你总共有 n 门课需要选，记为 0 到 n - 1.
一些课程在修之前需要先修另外的一些课程，比如要学习课程 0 你需要先学习课程 1 ，表示为[0,1]
给定n门课以及他们的先决条件，判断是否可能完成所有课程？

样例
例1:

输入: n = 2, prerequisites = [[1,0]] 
输出: true
例2:

输入: n = 2, prerequisites = [[1,0],[0,1]] 
输出: false

思路：这一题和上面一题其实差不多，只不过是给定的是一个二维数组，需要将其转化为一个map， 这一题和178类似

public class Solution {

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 如果为空则直接返回true
        if(prerequisites.length == 0 || numCourses == 0){
            return true;
        }
        // 先将二维数组转为map，根据题意可以理解为有向图
        Map<Integer, List<Integer>> map = getGraphList(numCourses, prerequisites);
        
        // 接下来给每一个节点计算入度
        Map<Integer, Integer> indegreeMap = new HashMap<>();
        for(int i = 0; i < numCourses; i++ ) {
            for(Integer neighbor : map.get(i)){
                if(indegreeMap.containsKey(neighbor)){
                    indegreeMap.put(neighbor, indegreeMap.get(neighbor) + 1);
                }else {
                    indegreeMap.put(neighbor, 1);
                }
            }
        }
        //寻找入度为0的节点
        Queue<Integer> queue = new LinkedList<>();
        List<Integer> resultList = new ArrayList<>();
        
        for(int i = 0; i < numCourses; i++) {
            if(!indegreeMap.containsKey(i)){
                queue.offer(i);
                resultList.add(i);
            }
        }
        
        while(!queue.isEmpty()){
            Integer head =  queue.poll();
            for(Integer neighbor : map.get(head)) {
                indegreeMap.put(neighbor, indegreeMap.get(neighbor)-1);
                if(indegreeMap.get(neighbor) == 0){
                    resultList.add(neighbor);
                    queue.offer(neighbor);
                }
            }
        }
        
        return resultList.size() == numCourses;
        
    }
    
    // 返回一个以map形式存储的图
    private Map<Integer, List<Integer>> getGraphList(int num, int [][] prerequisites){
        Map<Integer, List<Integer>> map = new HashMap<>();
        for(int i = 0; i < num; i++) {
            map.put(i, new ArrayList<Integer>());
        }
        for(int j = 0; j < prerequisites.length; j++){
            int u = prerequisites[j][0];
            int v = prerequisites[j][1];
            map.get(u).add(v);
        }
        return map;
    }
}