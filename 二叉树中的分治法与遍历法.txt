175. 翻转二叉树
中文English
翻转一棵二叉树。左右子树交换。
样例 1:

输入: {1,3,#}
输出: {1,#,3}
解释:
	  1    1
	 /  =>  \
	3        3

// 思路： 分治法，此题不复杂，只需要交换根节点root的两个子树即可，主要是遍历的退出条件是什么，如果遇到空节点则不需要做什么事情
public class Solution {
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    public void invertBinaryTree(TreeNode root) {
        // write your code here
        if(root == null) {
            return;
        }
        invertBinaryTree(root.left);
        invertBinaryTree(root.right);
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}



596. 最小子树
题目：给一棵二叉树, 找到和为最小的子树, 返回其根节点。
样例 1:
输入:
{1,-5,2,1,2,-4,-5}
输出:1
说明
这棵树如下所示：
     1
   /   \
 -5     2
 / \   /  \
1   2 -4  -5 
整颗树的和是最小的，所以返回根节点1.

// 分治法 + 递归（因为使用大了打擂台全局变量）
// 思想：使用分治法遍历每一个节点的左右子树，从最后一层叶子节点往上走，每一个节点都算出其左右子树加上根节点的总数，使用
//      打擂台全局变量获得总数sum最小的节点
// 使用返回值ResultType方法，其实理论是和分治 + 递归一样的，只不过是全局变量sum 和target节点使用一个自定义类进行封装，
// 方法helper返回的是一个ResultType类
public class Solution1 {

    private int sum = Integer.MAX_VALUE;
    private TreeNode target = null;
    public TreeNode findSubtree(TreeNode root) {
        // write your code here
        helper(root);
        return target;
    }
    
    int helper(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int left = helper(root.left);
        int right = helper(root.right);
        // 合并：左右子树和当根节点相加
        int tempSum = left + right + root.val;
        if(tempSum <= sum) {
            sum = tempSum;
            target = root;
        }
        return tempSum;
    }
}

// 返回值ResultType方法
// 思想：返回ResultType方法只是把上面的方法分治法转成的，其方法就是每次返回一个对象ResultType，这类封装了当前节点下总和最小的节点，最小值和
//      当前节点的总和，当节点左右子树都遍历完毕后，拿到返回的left，right对象与根节点进行比较，然后返回当前根节点里的目标只
class ResultType{
    public int sum;  // 当前根节点所有的节点总和
    public TreeNode target; //当前根节点
    public int minimum; // 目前整个子树中总数节点最小的树
    
    public ResultType(int sum, int minimum, TreeNode target) {
        this.sum = sum;
        this.target = target;
        this.minimum = minimum;
    }
}

public class Solution {
    /**
     * @param root: the root of binary tree
     * @return: the root of the minimum subtree
     */
    
    public TreeNode findSubtree(TreeNode root) {
        // write your code here
        return helper(root).target;
    }
    
    ResultType helper(TreeNode root){
        if(root == null) {
            return new ResultType(0, Integer.MAX_VALUE, null);
        }
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);
        
        ResultType result = new ResultType(left.sum + right.sum + root.val,
                                           left.sum + right.sum + root.val,
                                           root);
        if(left.minimum <= result.minimum) {
            result.minimum = left.minimum;
            result.target = left.target;
        }
        if(right.minimum <= result.minimum) {
            result.minimum = right.minimum;
            result.target = right.target;
        }
        return result;
    }
}


480. 二叉树的所有路径
题目：给一棵二叉树，找出从根节点到叶子节点的所有路径。
样例
样例 1:
输入：{1,2,3,#,5}
输出：["1->2->5","1->3"]
解释：
   1
 /   \
2     3
 \
  5

public class Solution {
    List<String> result = new ArrayList<String>();
    public List<String> binaryTreePaths(TreeNode root) {
        if(root == null) {
            return result;
        }
        helper(root, String.valueOf(root.val));
        return result;
    }
    
    // 递归法：每往下走一次就要把遍历到的节点接到结果字符串后面去，这样找到叶子节点后就可以加入到result里了
    void helper(TreeNode root, String path) {
        if(root == null) {
            return;
        }
        if(root.left == null && root.right == null) {
            result.add(path);
            return;
        }
        if(root.left != null) {
            helper(root.left, path + "->" + root.left.val);
        }
        if(root.right != null) {
            helper(root.right, path + "->" + root.right.val);
        }
    }
}

// 分治法：分治法其实是从底往根节点走，每次遍历走到叶子节点后就将两个叶子节点和根节点组装在一起成为放到
//         root.val + "->" + root.left.val, 一共有几个叶子节点就有几个路径
public class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> paths = new ArrayList<>();
        if(root == null) {
            return paths;
        }
        List<String> leftPaths = binaryTreePaths(root.left);
        List<String> rightPaths = binaryTreePaths(root.right);
        
        for(String path: leftPaths) {
            paths.add(root.val +"->" + path);
        }
        for(String path: rightPaths) {
            paths.add(root.val +"->" + path);
        }
	// 这一步判断只有在循环遍历到叶子节点才有作用，其他的时候不会使用到
        if(paths.size() == 0) {
            paths.add("" + root.val);
        }
        return paths;
    }
}



597. 具有最大平均数的子树
给一棵二叉树，找到有最大平均值的子树。返回子树的根结点。

样例
输入：
{1,-5,11,1,2,4,-2}
输出：11
说明:
这棵树如下所示：
     1
   /   \
 -5     11
 / \   /  \
1   2 4    -2 
11子树的平均值是4.333，为最大的。

// 思想：使用分治法 + 全局变量
//      分治法是从树的最底层往上遍历，肯定是遍历到了最左叶子节点，使用全局变量记录遍历到的节点的最大平均值，注意：思路不能陷入拿root节点和其左右
//      节点对比，而是要拿每一次遍历到的全局变量去对比，如果大于全局变量则记录最大值同时目标节点应该为当前节点

class ResultType{
    public int sum;  // 当前根节点所有的节点总和
    public int nodeCount; // 目前整个子树中总节点数量
    
    public ResultType(int sum, int nodeCount) {
        this.sum = sum;
        this.nodeCount = nodeCount;
    }
}
// 返回ResultType方法 == 分治法
public class Solution {
    /**
     * @param root: the root of binary tree
     * @return: the root of the maximum average of subtree
     */
    private TreeNode target = null;  // 每一次遍历找到的临时目标节点然后和上一层对比
    private ResultType tempResult = null;
    public TreeNode findSubtree2(TreeNode root) {
        // write your code here
        helper(root);
        return target;
    }
    
    // 方法的定义：找到当前节点的节点总节点数量，总值和，当前节点，最后求的平均值和左右子树对比
    // 注意⚠️：不能使用左右子树先比，找到大的在和root相比，如果左边大于root，那根节点的target值就为left了，但此时根节点的sum 和count还是原来的，
    //         如果往下走和right比较还是那原来的比较，这样就会出问题
    ResultType helper(TreeNode root){
        if(root == null) {
            return new ResultType(0, 0);
        }
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);

        // 当前root节点的下的值
        ResultType result = new ResultType(left.sum + right.sum + root.val,
                                            left.nodeCount + right.nodeCount + 1);
        // 使用tempResult打擂台
        if(target == null || result.sum * tempResult.nodeCount > result.nodeCount *  tempResult.sum) {
            target = root;
            tempResult = result;
        }
        return result;
    }
}


95. 验证二叉查找树
给定一个二叉树，判断它是否是合法的二叉查找树(BST)

一棵BST定义为：
1，节点的左子树中的值要严格小于该节点的值。
2，节点的右子树中的值要严格大于该节点的值。
3，左右子树也必须是二叉查找树。
4，一个节点的树也是二叉查找树。
样例

输入：{-1}
输出：true
解释：
二叉树如下(仅有一个节点）:
	-1
这是二叉查找树。


// 思路：使用分治法分别判断根节点的左右子树的是否为BST，最大值，最小值
//       拿下一层求得的左子树的最大值以及右子树的最小值分别和根结点对比
// ResultType定义：一个节点是不是BST，左子树最大值，右子树最小值
class ResultType{
    public boolean isBST;
    public int maxValue;
    public int minValue;
    
    public ResultType(boolean isBST, int maxValue, int minValue) {
        this.isBST = isBST;
        this.maxValue = maxValue;
        this.minValue = minValue;
    }
}

public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: True if the binary tree is BST, or false
     */
    public boolean isValidBST(TreeNode root) {
        // write your code here
        ResultType result = helper(root);
        return result.isBST;
    }
    ResultType helper(TreeNode root) {
        // 重点1：分治法的退出条件之一，当节点为空的时候也是一个BST，且最大最小值分分别为无穷小和务穷大
        if(root == null) {
            return new ResultType(true, Integer.MIN_VALUE, Integer.MAX_VALUE);
        }
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);
        if(!left.isBST || !right.isBST) {
            return new ResultType(false, 0, 0);
        }
        // 重点2：当前节点不为左子树不为空才去判断左边的最大值是否大于根节点，右节点相识
        if((root.left != null && left.maxValue >= root.val) || 
           (root.right != null && right.minValue <= root.val)) {
            return new ResultType(false, 0, 0);
        }
        // 重点3：返回以root为根节点子树中最大值和最小值，最后拼接一个完整的ResultType返回
        ResultType returnResult = new ResultType(true, 
                                                Math.max(root.val, right.maxValue), 
                                                Math.min(root.val, left.minValue));
        return returnResult;
    }
}

88. 最近公共祖先
给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。
最近公共祖先是两个节点的公共的祖先节点且具有最大深度。
样例

输入：{1},1,1
输出：1
解释：
 二叉树如下（只有一个节点）:
         1
 LCA(1,1) = 1


// 解体思路：将整个问题分解为一个简单的有根节点和两个叶子节点的树，这样分析问题
// 解法一：暴力解法，在有parent指针的情况下，对两个节点依次向上回溯，直到两个节点相同，那么这个节点就是最近公共祖先。时间复杂度为O(n²)
// 解法二：不借用额外的数据结构，没有parent指针。如果在某一个节点的时候，在当前节点的两个子树找到了AB，说明当前节点就是最近公共祖先节点，
// 如果在当前节点的某一个子树里没有发现其中的任何一个node，说明两个节点同在左子树或右子树，递归求解。不管先找到哪个node就返回当前节点

public class Solution {
    /*
     * @param root: The root of the binary search tree.
     * @param A: A TreeNode in a Binary.
     * @param B: A TreeNode in a Binary.
     * @return: Return the least common ancestor(LCA) of the two nodes.
     */
    // 如果以root为根节点的二叉树中
   // A 和 B 都存在则返回lCA，说明有公共节点的
   // A 和 B 都不存在则返回null
   // A存在 B不存在 则返回A
   // A不存在，B存在 则返回B
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode A, TreeNode B) {
        // write your code here
        // 遍历到其中一个根节点都还没有找到A或B，返回当前的root
        if(root == null) {
            return null;
        }
        // 当前遍历的这一层找到了A 或 B，就往上返回，一个子树只可能有其中一个点
        if(root == A || root == B) {
            return root;
        }
        // 这里的返回值就是找的一个A点或B点，如果为null说明没有找到
        TreeNode left = lowestCommonAncestor(root.left, A, B);
        TreeNode right = lowestCommonAncestor(root.right, A, B);
        
        // left 和 right不为空说明在left 和right中找到了A B所以可以返回root
        if(left != null && right != null) {
            return root;
        }
        if (left != null) {
            return left;
        }
        if(right != null) {
            return right;
        }
        return null;
    }
}