596. 最小子树
题目：给一棵二叉树, 找到和为最小的子树, 返回其根节点。
样例 1:
输入:
{1,-5,2,1,2,-4,-5}
输出:1
说明
这棵树如下所示：
     1
   /   \
 -5     2
 / \   /  \
1   2 -4  -5 
整颗树的和是最小的，所以返回根节点1.

// 分治法 + 递归（因为使用大了打擂台全局变量）
// 思想：使用分治法遍历每一个节点的左右子树，从最后一层叶子节点往上走，每一个节点都算出其左右子树加上根节点的总数，使用
//      打擂台全局变量获得总数sum最小的节点
// 使用返回值ResultType方法，其实理论是和分治 + 递归一样的，只不过是全局变量sum 和target节点使用一个自定义类进行封装，
// 方法helper返回的是一个ResultType类
public class Solution1 {

    private int sum = Integer.MAX_VALUE;
    private TreeNode target = null;
    public TreeNode findSubtree(TreeNode root) {
        // write your code here
        helper(root);
        return target;
    }
    
    int helper(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int left = helper(root.left);
        int right = helper(root.right);
        // 合并：左右子树和当根节点相加
        int tempSum = left + right + root.val;
        if(tempSum <= sum) {
            sum = tempSum;
            target = root;
        }
        return tempSum;
    }
}

// 返回值ResultType方法
// 思想：返回ResultType方法只是把上面的方法分治法转成的，其方法就是每次返回一个对象ResultType，这类封装了当前节点下总和最小的节点，最小值和
//      当前节点的总和，当节点左右子树都遍历完毕后，拿到返回的left，right对象与根节点进行比较，然后返回当前根节点里的目标只
class ResultType{
    public int sum;  // 当前根节点所有的节点总和
    public TreeNode target; //当前根节点
    public int minimum; // 目前整个子树中总数节点最小的树
    
    public ResultType(int sum, int minimum, TreeNode target) {
        this.sum = sum;
        this.target = target;
        this.minimum = minimum;
    }
}

public class Solution {
    /**
     * @param root: the root of binary tree
     * @return: the root of the minimum subtree
     */
    
    public TreeNode findSubtree(TreeNode root) {
        // write your code here
        return helper(root).target;
    }
    
    ResultType helper(TreeNode root){
        if(root == null) {
            return new ResultType(0, Integer.MAX_VALUE, null);
        }
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);
        
        ResultType result = new ResultType(left.sum + right.sum + root.val,
                                           left.sum + right.sum + root.val,
                                           root);
        if(left.minimum <= result.minimum) {
            result.minimum = left.minimum;
            result.target = left.target;
        }
        if(right.minimum <= result.minimum) {
            result.minimum = right.minimum;
            result.target = right.target;
        }
        return result;
    }
}


480. 二叉树的所有路径
题目：给一棵二叉树，找出从根节点到叶子节点的所有路径。
样例
样例 1:
输入：{1,2,3,#,5}
输出：["1->2->5","1->3"]
解释：
   1
 /   \
2     3
 \
  5

public class Solution {
    List<String> result = new ArrayList<String>();
    public List<String> binaryTreePaths(TreeNode root) {
        if(root == null) {
            return result;
        }
        helper(root, String.valueOf(root.val));
        return result;
    }
    
    // 递归法：每往下走一次就要把遍历到的节点接到结果字符串后面去，这样找到叶子节点后就可以加入到result里了
    void helper(TreeNode root, String path) {
        if(root == null) {
            return;
        }
        if(root.left == null && root.right == null) {
            result.add(path);
            return;
        }
        if(root.left != null) {
            helper(root.left, path + "->" + root.left.val);
        }
        if(root.right != null) {
            helper(root.right, path + "->" + root.right.val);
        }
    }
}

// 分治法：分治法其实是从底往根节点走，每次遍历走到叶子节点后就将两个叶子节点和根节点组装在一起成为放到
//         root.val + "->" + root.left.val, 一共有几个叶子节点就有几个路径
public class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> paths = new ArrayList<>();
        if(root == null) {
            return paths;
        }
        List<String> leftPaths = binaryTreePaths(root.left);
        List<String> rightPaths = binaryTreePaths(root.right);
        
        for(String path: leftPaths) {
            paths.add(root.val +"->" + path);
        }
        for(String path: rightPaths) {
            paths.add(root.val +"->" + path);
        }
	// 这一步判断只有在循环遍历到叶子节点才有作用，其他的时候不会使用到
        if(paths.size() == 0) {
            paths.add("" + root.val);
        }
        return paths;
    }