596. 最小子树
题目：给一棵二叉树, 找到和为最小的子树, 返回其根节点。
样例 1:
输入:
{1,-5,2,1,2,-4,-5}
输出:1
说明
这棵树如下所示：
     1
   /   \
 -5     2
 / \   /  \
1   2 -4  -5 
整颗树的和是最小的，所以返回根节点1.

// 分治法 + 递归（因为使用大了打擂台全局变量）
// 思想：使用分治法遍历每一个节点的左右子树，从最后一层叶子节点往上走，每一个节点都算出其左右子树加上根节点的总数，使用
//      打擂台全局变量获得总数sum最小的节点
// 使用返回值ResultType方法，其实理论是和分治 + 递归一样的，只不过是全局变量sum 和target节点使用一个自定义类进行封装，
// 方法helper返回的是一个ResultType类
public class Solution1 {

    private int sum = Integer.MAX_VALUE;
    private TreeNode target = null;
    public TreeNode findSubtree(TreeNode root) {
        // write your code here
        helper(root);
        return target;
    }
    
    int helper(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int left = helper(root.left);
        int right = helper(root.right);
        // 合并：左右子树和当根节点相加
        int tempSum = left + right + root.val;
        if(tempSum <= sum) {
            sum = tempSum;
            target = root;
        }
        return tempSum;
    }
}

// 返回值ResultType方法
// 思想：返回ResultType方法只是把上面的方法分治法转成的，其方法就是每次返回一个对象ResultType，这类封装了当前节点下总和最小的节点，最小值和
//      当前节点的总和，当节点左右子树都遍历完毕后，拿到返回的left，right对象与根节点进行比较，然后返回当前根节点里的目标只
class ResultType{
    public int sum;  // 当前根节点所有的节点总和
    public TreeNode target; //当前根节点
    public int minimum; // 目前整个子树中总数节点最小的树
    
    public ResultType(int sum, int minimum, TreeNode target) {
        this.sum = sum;
        this.target = target;
        this.minimum = minimum;
    }
}

public class Solution {
    /**
     * @param root: the root of binary tree
     * @return: the root of the minimum subtree
     */
    
    public TreeNode findSubtree(TreeNode root) {
        // write your code here
        return helper(root).target;
    }
    
    ResultType helper(TreeNode root){
        if(root == null) {
            return new ResultType(0, Integer.MAX_VALUE, null);
        }
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);
        
        ResultType result = new ResultType(left.sum + right.sum + root.val,
                                           left.sum + right.sum + root.val,
                                           root);
        if(left.minimum <= result.minimum) {
            result.minimum = left.minimum;
            result.target = left.target;
        }
        if(right.minimum <= result.minimum) {
            result.minimum = right.minimum;
            result.target = right.target;
        }
        return result;
    }
}


480. 二叉树的所有路径
题目：给一棵二叉树，找出从根节点到叶子节点的所有路径。
样例
样例 1:
输入：{1,2,3,#,5}
输出：["1->2->5","1->3"]
解释：
   1
 /   \
2     3
 \
  5

public class Solution {
    List<String> result = new ArrayList<String>();
    public List<String> binaryTreePaths(TreeNode root) {
        if(root == null) {
            return result;
        }
        helper(root, String.valueOf(root.val));
        return result;
    }
    
    // 递归法：每往下走一次就要把遍历到的节点接到结果字符串后面去，这样找到叶子节点后就可以加入到result里了
    void helper(TreeNode root, String path) {
        if(root == null) {
            return;
        }
        if(root.left == null && root.right == null) {
            result.add(path);
            return;
        }
        if(root.left != null) {
            helper(root.left, path + "->" + root.left.val);
        }
        if(root.right != null) {
            helper(root.right, path + "->" + root.right.val);
        }
    }
}

// 分治法：分治法其实是从底往根节点走，每次遍历走到叶子节点后就将两个叶子节点和根节点组装在一起成为放到
//         root.val + "->" + root.left.val, 一共有几个叶子节点就有几个路径
public class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> paths = new ArrayList<>();
        if(root == null) {
            return paths;
        }
        List<String> leftPaths = binaryTreePaths(root.left);
        List<String> rightPaths = binaryTreePaths(root.right);
        
        for(String path: leftPaths) {
            paths.add(root.val +"->" + path);
        }
        for(String path: rightPaths) {
            paths.add(root.val +"->" + path);
        }
	// 这一步判断只有在循环遍历到叶子节点才有作用，其他的时候不会使用到
        if(paths.size() == 0) {
            paths.add("" + root.val);
        }
        return paths;
    }
}



597. 具有最大平均数的子树
给一棵二叉树，找到有最大平均值的子树。返回子树的根结点。

样例
输入：
{1,-5,11,1,2,4,-2}
输出：11
说明:
这棵树如下所示：
     1
   /   \
 -5     11
 / \   /  \
1   2 4    -2 
11子树的平均值是4.333，为最大的。

// 思想：使用分治法 + 全局变量
//      分治法是从树的最底层往上遍历，肯定是遍历到了最左叶子节点，使用全局变量记录遍历到的节点的最大平均值，注意：思路不能陷入拿root节点和其左右
//      节点对比，而是要拿每一次遍历到的全局变量去对比，如果大于全局变量则记录最大值同时目标节点应该为当前节点

class ResultType{
    public int sum;  // 当前根节点所有的节点总和
    public int nodeCount; // 目前整个子树中总节点数量
    
    public ResultType(int sum, int nodeCount) {
        this.sum = sum;
        this.nodeCount = nodeCount;
    }
}
// 返回ResultType方法 == 分治法
public class Solution {
    /**
     * @param root: the root of binary tree
     * @return: the root of the maximum average of subtree
     */
    private TreeNode target = null;  // 每一次遍历找到的临时目标节点然后和上一层对比
    private ResultType tempResult = null;
    public TreeNode findSubtree2(TreeNode root) {
        // write your code here
        helper(root);
        return target;
    }
    
    // 方法的定义：找到当前节点的节点总节点数量，总值和，当前节点，最后求的平均值和左右子树对比
    // 注意⚠️：不能使用左右子树先比，找到大的在和root相比，如果左边大于root，那根节点的target值就为left了，但此时根节点的sum 和count还是原来的，
    //         如果往下走和right比较还是那原来的比较，这样就会出问题
    ResultType helper(TreeNode root){
        if(root == null) {
            return new ResultType(0, 0);
        }
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);

        // 当前root节点的下的值
        ResultType result = new ResultType(left.sum + right.sum + root.val,
                                            left.nodeCount + right.nodeCount + 1);
        // 使用tempResult打擂台
        if(target == null || result.sum * tempResult.nodeCount > result.nodeCount *  tempResult.sum) {
            target = root;
            tempResult = result;
        }
        return result;
    }
}